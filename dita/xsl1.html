<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Steve Hoenisch">
  <title>An Introduction to XSLT – Using Stylesheets to Separate Content from Presentation</title>
  <meta name="description" content="A magazine article that introduces you to the art and craft of using XSLT stylesheets to separate content from presentation in XML documents.">
  <meta name="keywords" content="XML, XSL, XSLT, CSS, markup, markup strategies, XML documents, XML structuring, structuring XML documents, XHTML, content, presentation, DTD, formatting XML, XSL:FO, formatting objects">
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" type="text/css" />
  <link href="/aw/css/navbar-fixed-side.css" rel="stylesheet" />
  <link rel="stylesheet" type="text/css" href="/aw/css/custom.css" />
  <link rel="stylesheet" type="text/css" media="print" href="/aw/css/print.css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" type="text/css" />
</head>
<body>
<div id="doc" class="container-fluid">

<!-- ============================================= -->

<div class="container-fluid">
  <div class="row">
    <div class="col-sm-3 col-lg-2 col-sm-push-9 col-lg-push-10">
      <nav class="navbar navbar-inverse navbar-fixed-side">
        <!-- normal collapsable navbar markup -->

  <div class="container">
              <div class="navbar-header">
                <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://www.criticism.com">Criticism.Com</a>
              </div>
              <div class="collapse navbar-collapse">
                <ul class="nav navbar-nav">

                   <li class="active">
                    <a href="/critical-theory/">Critical Theory</a>
                  </li>

                   <li class="">
                    <a href="/da/">Discourse Analysis</a>
                  </li>

                  <!--
                   <li class="">
                    <a href="/linguistics/">Linguistics</a>
                  </li>
                  -->
         
                  <li class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#">Technology <b class="caret"></b></a>

                  <ul class="dropdown-menu">
                  <li><a href="/cc/white-papers.html">White Papers</a></li>
                  
                    <li><a href="/cc/blog.html">Blog</a></li>
                  <!-- <li><a href="/md/bio.html">Resume</a></li> -->

                <!--   
                  <li class="divider"></li>
              
                  <li class="dropdown-header">Dropdown Header</li>
                  <li><a href="#">Sub-page 3</a></li> -->

                  </ul>
                 </li>
    

                  <li class="">
                    <a href="/map.html">Site Map</a>
                  </li>
    


                    </ul>

                <!--         
                <ul class="nav navbar-nav navbar-right">
                  <li><a href="#">Page 4</a></li>


                </ul> -->
         

                <p class="navbar-text"><i class="fa fa-cloud-upload fa-inverse" aria-hidden="true"></i> <i>Head in the clouds, feet on the ground.</i>

                </p>
                <p class="navbar-text"><i class="fa fa-flask fa-inverse" aria-hidden="true"></i> Criticism.Com presents white papers and essays on technology, media, critical theory, discourse analysis, and linguistics. The future is critical. 
                </p>

              </div>
            </div>

     </nav>
    </div>
    <div class="col-sm-9 col-lg-10 col-sm-pull-3 col-lg-pull-2">
      <!-- your page content: -->

<!-- ============================================= -->
<header>
<h1 class="title">An Introduction to XSLT – Using Stylesheets to Separate Content from Presentation</h1>
<p class="author"><i class="fa fa-user-secret" aria-hidden="true"></i></i> Steve Hoenisch</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#indoctrination">INDOCTRINATION</a></li>
<li><a href="#xslt-xsl-fo-and-css">XSLT, XSL-FO, AND CSS</a></li>
<li><a href="#preliminaries-principles-of-separation">PRELIMINARIES: PRINCIPLES OF SEPARATION</a></li>
<li><a href="#xslts-atom-the-template-rule">XSLT’S ATOM: THE TEMPLATE RULE</a></li>
<li><a href="#related-tutorials">RELATED TUTORIALS</a></li>
</ul>
</nav>
<p>This article appeared in Volume 3, Issue 1 of <em>XML Journal</em> magazine.</p>
<h3 id="indoctrination">INDOCTRINATION</h3>
<p>You’ve probably heard the propaganda by now: XML blesses you with a way to separate content from presentation. Separation in turn yields productive gains over HTML and other data formats used to manage content: In a process sometimes called single-sourcing, the content of an XML document can be formatted for display in a web browser, reformatted for delivery to such devices as mobile phones and handheld computers, and converted into a PDF file suitable for printing.</p>
<p>A news story, for example, that has been marked up in XML can be transformed into HTML for publication on a web site, converted into Wireless Markup Language (WML) for display on a cell phone’s screen, and rendered into a format from which a PDF file can be generated. Meantime, parts of the news story, such as paragraphs that supply background information about a given subject, can be reused in other XML-encoded news stories. What makes all this possible? XSLT.</p>
<p><img src="/images/xmlj_v3i1.jpg" align="right"/></p>
<p>Extensible Stylesheet Language for Transformations, or XSLT, is a functional programming language that enables us to bridge the gap between content and presentation by providing a means of specifying how a content-based XML document is transformed into a presentation-oriented document or data format.</p>
<p>This tutorial, written primarily for content authors, technical writers, web designers, and other nonprogrammers, is the first in a short series that aims to introduce you to the basics of XSLT and to help you get started using it to transform XML documents into HTML. The focus is not on data-centric documents but on such narrative-centric documents as reference manuals, help files, essays, stories, instructions, books, and magazine articles.</p>
<p>I’ll begin by briefly summarizing the background of XSL and contrasting XSLT with XSL-FO and Cascading Style Sheets (CSS). Along the way I’ll discuss what XSLT is, what it can do, and how to use it in conjunction with CSS to separate content from presentation. The next section will introduce you to XSLT’s most fundamental component, the template rule, and demonstrate how to write one, culminating in a simple XSLT stylesheet that uses Internet Explorer 5.5’s XSLT processor to transform a simple XML document into an HTML document.</p>
<h3 id="xslt-xsl-fo-and-css">XSLT, XSL-FO, AND CSS</h3>
<p>The birth of XSLT breaks down like this: Extensible Stylesheet Language (XSL) was conceived as an XML application for expressing stylesheets capable of manipulating XML documents. After its submission to the W3C in 1997, XSL split into two stylesheet standards: Extensible Stylesheet Language for Transformations (XSLT) and Extensible Stylesheet Language Formatting Objects (XSL-FO). XSLT is a language for transforming XML documents into typically other XML documents, HTML, and WML, but can also be used to produce documents in plain text and XSL-FO. XSL-FO is used to describe the layout of XML documents for printing, with the end product usually being in Portable Document Format (PDF). XSL-FO, a complex standard that some refer to as simply XSL, may eventually also be employed to lay out web pages, though this use is unsupported by current versions of web browsers. You can find more information about XSLT and XSL-FO, including their specifications, on the World Wide Web Consortium’s web site, www.w3c.org. This column focuses on XSLT; later tutorials will expand on XSLT and delve into XSL-FO.</p>
<p>The early XSL proposals also gave rise to another breakaway standard, XPath. It grew out of the location-finding aspects of the XSL and XPointer specifications, which had been independently using similar mechanisms to find information in XML documents. XSLT heavily uses XPath to locate specific nodes or node sets within XML documents. Details about XPath specification can be found at http://www.w3c.org/TR/xpath.</p>
<p>XSL has another related standard, though unlike XSL it is not based in XML: Cascading Style Sheets (CSS). In the context of web publishing, Cascading Style Sheets (CSS) can also be used, at least theoretically, to statically format XML documents for display, but it cannot be used to transform them in any meaningful way. For example, XMetal, a tool for writing and editing in XML, uses CSS to format XML documents for display in its normal view. But until there is much stronger web browser support for displaying XML documents with CSS, it is not a practical option for web publishing.</p>
<p>CSS is not a competitor of XSLT. CSS is a method for statically formatting an XML document in a way that allows you to separate formatting and styling information from the document, but it does not allow you to dynamically transform an XML document into another data format. With CSS, you cannot manipulate the structure of an XML document, change the ordering of content, or dynamically generate a table of contents from a set of headings. Only XSLT can do that.</p>
<p>Using CSS to complement XSLT, however, is a powerful strategy for building web pages – a strategy that splits presentation into what I call formatting and styling. Formatting can be seen to include basic HTML markup like headings, horizontal rules, lists and the like. Styling, meantime, defines the visual properties of markup: Its colors, sizes, widths, margins, bullet types, and so forth. Although the distinction between the two is not always clear-cut, formatting typically appears in the form of elements, styling information in the form of attribute-value pairs. For example, in <code>&lt;h1 style=&quot;color: olive;&quot;&gt;</code> the h1 element formats the text as a first-level heading while the values of the style attribute, used for specifying inline CSS styles, reflect how the text should be styled.</p>
<p>You can gain a great deal of utility from separating as much styling information as possible from the formatting and placing it a Cascading Style Sheet, though until the second major version of CSS, CSS Level 2, is better supported by browsers, your HTML formatting markup will still have to retain some styling information, such as that for tables. Separating visual styling from formatting gives you a way to make wholesale design changes to a web site without having to change the formatting code in every HTML document; if you’ve set up your web pages properly, with all of them linking to a single CSS, you merely make the changes in one file, the Cascading Style Sheet. Cascading Style Sheets: The Definitive Guide, published by O’Reilly, provides a detailed account of how to use CSS. The W3C CSS specifications are available at http://www.w3c.org/Style/CSS/. In this tutorial, I will begin demonstrating how to use CSS with XSLT to separate styling from formatting, and I’ll expand on the topic in later tutorials.</p>
<h3 id="preliminaries-principles-of-separation">PRELIMINARIES: PRINCIPLES OF SEPARATION</h3>
<p>There are other principles of separation that can be immensely useful in building well-engineered, text-based web pages with XML, XSLT, CSS, and HTML. An overarching objective is to use XML to structure content and XSLT and CSS to format it in a way that minimizes redundancy and maximizes flexibility, including the capability to repurpose content and publish it in various formats. Most of the principles listed below are best applied to narrative-oriented documents that will be published as white papers, technical manuals, help files, essays, and so forth. Keep in mind that these principles are merely a guide and that the list of exceptions is long: Your data, purpose, audience, delivery format, and other factors will influence how you engineer your system’s own matrix of structure, metainformation, parameters, content, and presentation.</p>
<ul>
<li><p>XML documents: Strive to maximize the content that exists as text, not as tags, in your XML documents. In other words, content that you expect end users to see should usually be set as content, not as elements or attributes. Avoid setting content as tags, either as elements or attributes, even if doing so comes at the cost of some redundancy; it’s easier for content authors to work with content that is out in the open, not hidden as the value of attributes or as elements themselves. Instead, use elements to describe the structure or content of your material; use attributes to capture metainformation about the content or its structure and to encode parameters that are used to process the content. Place recurring content, especially content that may change, such as the name of a product under development, in entities. Shy away from placing formatting or styling information in your XML documents, though it may be expedient to include some table and image formatting instructions.</p></li>
<li><p>XSLT stylesheets: Place as much formatting information as possible in your XSLT stylesheet and eschew using it as a container for standard content. Instead, place content out in the open in your XML documents even if doing so comes as the expense of a little duplication. However, highly variable content, such as the date of publication and the version number, may be best placed in the XSLT stylesheet as entities. It may also benefit you to make exceptions for content that varies by audience, as in the case of parameterized settings used in internationalization.</p></li>
<li><p>Cascading Stylesheets, as I mentioned above, should complement the XSLT stylesheet by containing as many as possible of the formatting code’s visual styling properties.</p></li>
</ul>
<p>In the examples that accompany this and later tutorials in the series, you’ll see some of these principles at work.</p>
<h3 id="xslts-atom-the-template-rule">XSLT’S ATOM: THE TEMPLATE RULE</h3>
<p>In its most basic form, an XSLT stylesheet uses what are called template rules to match nodes in an XML document and transform them into another format. (Actually, it is the XSLT processor that takes an XML document, called a source tree, and an XSLT stylesheet as input and uses them to produce a result tree as output, which can then be serialized into a file, but we need not worry about such technicalities just yet.) A template rule is an XSL element that matches a node in the XML source document and typically applies an output format to it. For example, say you have the following simple XML document:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;source&gt;
     &lt;message&gt;Greetings and Salutations.&lt;/message&gt;
&lt;/source&gt;</code></pre>
<p>You can use a template rule to find the children of the <code>&lt;source&gt;</code> element and to format its contents in HTML for presentation. Here’s an XSLT template rule that does just that:</p>
<pre><code>&lt;xsl:template match=&quot;/&quot;&gt;
     &lt;html&gt;
          &lt;body&gt;
               &lt;h1&gt;&lt;xsl:apply-templates/&gt;&lt;/h1&gt;
          &lt;/body&gt;
     &lt;/html&gt;
&lt;/xsl:template&gt;</code></pre>
<p>In the above rule, the <code>&lt;xsl:template match=&quot;/&quot;&gt;</code> element uses the value of its match attribute to find a node in the XML source. The forward slash operator, an XPath expression, specifies the document’s root node. The rule could also match on the same node by specifying it explicitly in the template rule, that is, <code>&lt;xsl:template match=&quot;source&quot;&gt;</code>. By matching on the root node of the document, we’re able to build an HTML container that provides the skeleton code (here, just <code>&lt;html&gt;</code> and <code>&lt;body&gt;</code>) for our document.</p>
<p>The <code>&lt;xsl:apply-templates&gt;</code> element invokes a built-in XSLT template rule that processes the children of the matched node, meaning roughly that it outputs the children. Because there is only one child of the <code>&lt;source&gt;</code> node in our XML file, <code>&lt;xsl:apply-templates&gt;</code> suffices to print the meager contents of the file. If, however, the <code>&lt;source&gt;</code> element contained more children, <code>&lt;xsl:apply-templates&gt;</code> would print all of them out, too, and we would want additional template rules to control how they are processed and outputted.</p>
<p>Before we can push our source XML and its accompanying stylesheet through an XSLT processor to render the HTML output, we need do a couple more things. First, we need to add an XML processing instruction to the top of the stylesheet. Second, we must wrap the template rule with the <code>&lt;xsl:stylesheet&gt;</code> element, which all XSL stylesheets require as their top-level element, and set a namespace for it (note that some versions of Internet Explorer and the MSXML parser may require a different namespace; see http://msdn.microsoft.com/ for details):</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; 
version=&quot;1.0&quot;&gt;
     &lt;xsl:template match=&quot;/&quot;&gt;
          &lt;html&gt;
               &lt;body&gt;
                    &lt;h1&gt;&lt;xsl:apply-templates/&gt;&lt;/h1&gt;
               &lt;/body&gt;
          &lt;/html&gt;
     &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code></pre>
<p>We now have a minimal stylesheet that will convert our XML source to HTML. To view the output in Internet Explorer 5.5 or greater, we first need to make a change to the XML source document: It must include a stylesheet processing instruction, appended after the XML processing instruction, that references our new minimal stylesheet, which is in this case located in the same directory as the source file, as the path in the href attribute’s value testifies:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;?xml:stylesheet type=&quot;text/xsl&quot; href=&quot;my_stylesheet.xsl&quot;?&gt;
&lt;source&gt;
     &lt;message&gt;Greetings and Salutations.&lt;/message&gt;
&lt;/source&gt;</code></pre>
<p>Let’s expand our minimal stylesheet to do a few more things. First, we’ll modify our template rule to output the message element specifically (as opposed to all the children of the root element); second, we’ll add a link to a Cascading Style Sheet that specifies the visual properties of our HTML formatting:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; 
version=&quot;1.0&quot; &gt;
     &lt;xsl:template match=&quot;source&quot;&gt;
          &lt;html&gt;
               &lt;head&gt;
                    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;my_styles.css&quot;/&gt;
               &lt;/head&gt;
               &lt;body&gt;
                    &lt;h1&gt;&lt;xsl:value-of select=&quot;message&quot;/&gt;&lt;/h1&gt;
               &lt;/body&gt;
          &lt;/html&gt;
     &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code></pre>
<p>This stylesheet first matches the root node explicitly by name (source), builds an HTML container for it as before, and then uses the <code>&lt;xsl:value-of&gt;</code> element to select and output the text contents of the message node. The select attribute identifies the element whose contents are to be processed.</p>
<p>Notice that in the stylesheet I also added a link to a CSS file in the same directory as the XSLT stylesheet. The CSS file contains the following code: h1 { color: olive; } This simple code selects the <code>&lt;h1&gt;</code> element and renders it in olive in Internet Explorer, effectively separating the color aspect of the heading’s visual style from its HTML formatting code in the XSLT stylesheet.</p>
<p>Because XSLT is a programming language, there’s a great deal more to it than the simple examples shown above. To reinforce this column’s brief introduction, I suggest you read Chapter 6, Transformation: Repurposing Documents, in O’Reilly’s Learning XML. I also suggest you start playing around with XSLT a little on your own; it’s the best way to learn how to use it. Try creating an XML document and write some simple template matching rules like those above to process your source and output it in Internet Explorer. My next column will delve deeper into XSLT to unearth its complexity and accompanying power.</p>
<h3 id="related-tutorials">RELATED TUTORIALS</h3>
<p>The tutorials in this series proceed as follows:</p>
<ol type="1">
<li><a href="xml_intro.html">An Introduction to XML</a></li>
<li><a href="structuring_docs.html">Structuring Documents in XML</a></li>
<li><a href="dtd1.html">Developing a Document Type Definition</a></li>
<li><a href="dtd2.html">Attributes and Entities in DTDs</a></li>
<li><a href="xsl1.html">An Introduction to XSL</a> <i class="fa fa-check-square" aria-hidden="true"></i></li>
<li><a href="xsl2.html">Using XSLT to Separate Content from Presentation</a></li>
</ol>
<hr />
<script type="text/javascript" src="https://platform.linkedin.com/badges/js/profile.js" async defer></script>
<div class="LI-profile-badge" data-version="v1" data-size="medium" data-locale="en_US" data-type="horizontal" data-theme="light" data-vanity="steve-hoenisch-4092344b">
<a class="LI-simple-link" href='https://www.linkedin.com/in/steve-hoenisch-4092344b?trk=profile-badge'>Steve Hoenisch</a>
</div>
<hr height="1" style="color: silver;">

<div class="footer">

<!-- <p>&nbsp;</p> -->

<span style="font-size: 80%;" class="botLinks">
<i class="fa fa-flask" aria-hidden="true"></i> <a class="botLink" href="/cc/white-papers.html">White Papers</a>
| <i class="fa fa-language" aria-hidden="true"></i> <a class="botLink" href="/linguistics/index.html"> Linguistics</a>
| <i class="fa fa-coffee" aria-hidden="true"></i> <a class="botLink" href="/critical-theory/index.html"> Critical Theory</a> 
| <i class="fa fa-random" aria-hidden="true"></i> <a class="botLink" href="/da/index.html"> Discourse Analysis</a> 
</span><hr height="1" style="color: silver;">
<span style="font-size: 80%;" class="botLinks"><font color="gray">Copyright © 1995-2020</font>  
<a class="botLink" href="/md/resume.html" style="color: gray;">Steve Hoenisch</a> <font color="gray">and <a class="botLink" href="/" style="color: gray;">Criticism.Com</a>. All rights reserved. Disclaimer: The views and opinions expressed on Criticism.Com are strictly my own and are not the opinions or views of the company that I work for now or any company that I have worked for in the past. </font><a class="botLink" href="/map.html"> Site Map</a> <i class="fa fa-sitemap" aria-hidden="true"></i>
</span>
 <hr height="1" style="color: silver;">
 <p/>
</div>

</div>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
</body>
</html>
